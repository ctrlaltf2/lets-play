syntax = "proto3";
option optimize_for = SPEED;

// This .proto contains definitions that are used for IPC between
// letsplayd and a runner process implemented using the letsplay_runner_core Rust crate.
// They allow letsplayd to communicate with a runner connected to it and vice versa. 

// The type of an input device.
enum InputDeviceType {
	// A joypad (probably the default).
	JOYPAD = 0;

	// Analog joypad This will provide stick messages.
	JOYPAD_ANALOG = 1;

	// Keyboard and mouse.
	KB_MOUSE = 2;
}

// joystick inputs
message JoystickInput {
	message Stick {
		float x = 2;
		float y = 3;
	}

	// Buttons. It is assumed that 64-bit precision will be enough,
	// but I am providing a gap in this message to put more fields if needed.
	// Later on these should probably be defined somewhere or something.
	fixed64 buttons = 1;

	// Sticks are sent in order (and always for the correct count of joysticks)
	repeated Stick sticks = 10;
}

message KbMouseInput {
	message Keyboard {
		message Key {
			uint32 keysym = 1;
			bool pressed = 2;
		}	

		repeated Key keys = 1;
	}

	message Mouse {
		uint32 x = 1;
		uint32 y = 2;
		uint32 buttons = 3;
	}
}

// A request made by letsplayd
message ServerMessage {
	// Shut down the runner.
	message Shutdown {}

	// Reset the game 
	message Reset {}

	// initialize
	message Initalize {}

	// Controls the runner's suspend flag.
	//
	// Setting this flag to true tells the runner to (temporarily) inhibit the
	// runner thread from executing, thereby "suspending" emulation. (Additionally, 
	// while suspended, we should disable certain other routine tasks, and re-enable them
	// when leaving suspend. )
	// 
	// Likewise, false turns off the suspend flag, and allows the runner thread to run.
	//
	// Ideally this could be done if the emulator node the runner is for is empty after
	// a certain period of time.
	message SetSuspend {
		bool suspend = 1;
	}

	message SetProperty {
		// The key to set. This is optionally namespaced per-runner type, with some generic ones provided.
		// We could probably use google protobuf any type but /shrug
		// Example K/V set:
		// "gpu_device", "[index]"
		// "libretro.core", "/path/to/core.so",
		// "libretro.rom", "/path/to/rom"
		string key = 1;
		string value = 2;
	}

	// Inserts a input device. This typically occurs only at the start of a game
	// (for the amount of players configured).
	message InsertInputDevice {
		int32 index = 1;
		InputDeviceType type = 2;
	}

	// Provides new inputs to use.
	message Input {
		// The device index to populate with new inputs.
		int32 index = 1;

		oneof Oneof {
			JoystickInput joy_input = 2;
			KbMouseInput kbm_input = 3;
		}
	}

	// "Unplugs" (removes) an input device. 
	message UnplugInputDevice {
		int32 index = 1;
	}

}

// A message sent to letsplayd.
message ClientMessage {
	message Hello {
		// Returns a standardized type id, like:
		// 'letsplay.libretro'
		string typeid = 1;
	}
}
